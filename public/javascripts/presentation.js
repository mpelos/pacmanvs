// Generated by CoffeeScript 1.3.3
var BasicPlayer, Collider, Coordinate, Direction, Entity, Food, Game, Ghost, GhostRenderer, MAPS_MATRIX, Map, Pacman, PacmanRenderer, Player, PlayerRenderer, Presentation, Rectangle, Slide, Tile, Timer,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

(function() {
  var time, vendor, _i, _len, _ref;
  time = 0;
  _ref = ["ms", "moz", "webkit", "o"];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    vendor = _ref[_i];
    if (!(!window.requestAnimationFrame)) {
      continue;
    }
    window.requestAnimationFrame = window[vendor + "RequestAnimationFrame"];
    window.cancelRequestAnimationFrame = window[vendor + "CancelRequestAnimationFrame"];
  }
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback, element) {
      var delta, now, old;
      now = new Date().getTime();
      delta = Math.max(0, 16 - (now - old));
      setTimeout((function() {
        return callback(time + delta);
      }), delta);
      return old = now + delta;
    };
  }
  if (!window.cancelAnimationFrame) {
    return window.cancelAnimationFrame = function(id) {
      return clearTimeout(id);
    };
  }
})();

Timer = (function() {

  function Timer(time) {
    this.time = time;
    this.startTime = new Date;
  }

  Timer.prototype.spentTime = function() {
    return new Date - this.startTime;
  };

  Timer.prototype.timeOver = function() {
    return this.spentTime() >= this.time;
  };

  Timer.prototype.setTime = function(time) {
    this.time = time;
    return this.reset();
  };

  Timer.prototype.reset = function() {
    return this.startTime = new Date;
  };

  return Timer;

})();

Coordinate = (function() {

  function Coordinate(x, y) {
    this.x = x;
    this.y = y;
  }

  Coordinate.prototype.set = function() {
    var position;
    if (arguments[0] instanceof Coordinate) {
      position = arguments[0];
      this.x = position.x;
      return this.y = position.y;
    } else {
      this.x = arguments[0];
      return this.y = arguments[1];
    }
  };

  Coordinate.prototype.betweenAxisX = function(x1, x2) {
    var _ref, _ref1;
    return (x1 < (_ref = this.x) && _ref < x2) || (x1 > (_ref1 = this.x) && _ref1 > x2);
  };

  Coordinate.prototype.betweenAxisY = function(y1, y2) {
    var _ref, _ref1;
    return (y1 < (_ref = this.y) && _ref < y2) || (y1 > (_ref1 = this.y) && _ref1 > y2);
  };

  Coordinate.prototype.betweenAxis = function(coordinate1, coordinate2) {
    return this.betweenAxisX(coordinate1.x, coordinate2.x) || this.betweenAxisY(coordinate1.y, coordinate2.y);
  };

  Coordinate.prototype.toString = function() {
    return "" + this.x + ", " + this.y;
  };

  return Coordinate;

})();

Direction = (function() {

  function Direction(direction) {
    this.angle = this.parse(direction);
  }

  Direction.prototype.parse = function(direction) {
    if (typeof direction === "string") {
      switch (direction.toLowerCase()) {
        case "right":
          return 0;
        case "down":
          return Math.PI * 0.5;
        case "left":
          return Math.PI;
        case "up":
          return Math.PI * 1.5;
      }
    } else if (direction instanceof Coordinate) {
      switch (direction.toString()) {
        case "1, 0":
          return 0;
        case "0, -1":
          return Math.PI * 0.5;
        case "-1, 0":
          return Math.PI;
        case "0, 1":
          return Math.PI * 1.5;
      }
    } else if (typeof direction === "number") {
      return direction;
    } else if (direction instanceof Direction) {
      return direction.angle;
    } else {
      return null;
    }
  };

  Direction.prototype.set = function(direction) {
    return this.angle = this.parse(direction);
  };

  Direction.prototype.toCoordinate = function() {
    switch (this.angle) {
      case 0:
        return new Coordinate(1, 0);
      case Math.PI * 0.5:
        return new Coordinate(0, 1);
      case Math.PI:
        return new Coordinate(-1, 0);
      case Math.PI * 1.5:
        return new Coordinate(0, -1);
    }
  };

  Direction.prototype.toString = function() {
    switch (this.angle) {
      case 0:
        return "right";
      case Math.PI * 0.5:
        return "down";
      case Math.PI:
        return "left";
      case Math.PI * 1.5:
        return "up";
    }
  };

  return Direction;

})();

Rectangle = (function() {

  function Rectangle(position, width, height) {
    this.position = position;
    this.width = width;
    this.height = height;
  }

  Rectangle.prototype.topLeft = function() {
    return new Coordinate(this.position.x - this.width / 2, this.position.y - this.height / 2);
  };

  Rectangle.prototype.topRight = function() {
    return new Coordinate(this.position.x + this.width / 2 - 0.5, this.position.y - this.height / 2);
  };

  Rectangle.prototype.bottomRight = function() {
    return new Coordinate(this.position.x + this.width / 2 - 0.5, this.position.y + this.height / 2 - 0.5);
  };

  Rectangle.prototype.bottomLeft = function() {
    return new Coordinate(this.position.x - this.width / 2, this.position.y + this.height / 2 - 0.5);
  };

  Rectangle.prototype.toArray = function() {
    return [this.topLeft(), this.topRight(), this.bottomRight(), this.bottomLeft()];
  };

  Rectangle.prototype.isIntersected = function(other) {
    var isIntersectOnXAxis, isIntersectOnYAxis, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    isIntersectOnXAxis = (this.topLeft().x <= (_ref = other.topLeft().x) && _ref <= this.topRight().x) || (this.topLeft().x <= (_ref1 = other.topRight().x) && _ref1 <= this.topRight().x) || (other.topLeft().x <= (_ref2 = this.topLeft().x) && _ref2 <= other.topRight().x) || (other.topLeft().x <= (_ref3 = this.topRight().x) && _ref3 <= other.topRight().x);
    isIntersectOnYAxis = (this.topRight().y <= (_ref4 = other.topRight().y) && _ref4 <= this.bottomRight().y) || (this.topRight().y <= (_ref5 = other.bottomRight().y) && _ref5 <= this.bottomRight().y);
    (other.topRight().y <= (_ref6 = this.topRight().y) && _ref6 <= other.bottomRight().y) || (other.topRight().y <= (_ref7 = this.bottomRight().y) && _ref7 <= other.bottomRight().y);
    return isIntersectOnXAxis && isIntersectOnYAxis;
  };

  return Rectangle;

})();

Entity = (function() {

  function Entity(x, y, map) {
    this.map = map;
    this.position = new Coordinate(x, y);
    this.initialPosition = new Coordinate(x, y);
    this.boundingBox = new Rectangle(this.position, Map.tileWidth, Map.tileHeight);
  }

  Entity.prototype.currentTiles = function(positions) {
    var i, j, position, tiles, _i, _len;
    if (positions == null) {
      positions = this.boundingBox.toArray();
    }
    if (!(positions instanceof Array)) {
      positions = [positions];
    }
    tiles = [];
    for (_i = 0, _len = positions.length; _i < _len; _i++) {
      position = positions[_i];
      i = Math.floor(position.y / Map.tileHeight);
      j = Math.floor(position.x / Map.tileWidth);
      tiles.push(this.map.tiles[i][j]);
    }
    return _.uniq(tiles);
  };

  Entity.prototype.excludeFromTiles = function() {
    var entity, tile, tileEntities, _i, _j, _len, _len1, _ref, _ref1, _results;
    _ref = this.currentTiles();
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      tile = _ref[_i];
      if (tile) {
        tileEntities = [];
        _ref1 = tile.entities;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          entity = _ref1[_j];
          if (entity !== this) {
            tileEntities.push(entity);
          }
        }
        _results.push(tile.entities = tileEntities);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Entity.prototype.includeIntoTiles = function() {
    var tile, _i, _len, _ref, _results;
    _ref = this.currentTiles();
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      tile = _ref[_i];
      _results.push(tile != null ? tile.entities.push(this) : void 0);
    }
    return _results;
  };

  Entity.prototype.isIntersected = function(other) {
    return this.boundingBox.isIntersected(other.boundingBox);
  };

  Entity.prototype.drawBoundingBox = function(context) {
    context.lineWidth = 2;
    context.strokeStyle = "red";
    return context.strokeRect(this.boundingBox.topLeft().x, this.boundingBox.topLeft().y, this.boundingBox.width, this.boundingBox.height);
  };

  Entity.prototype.reset = function() {};

  return Entity;

})();

Food = (function(_super) {

  __extends(Food, _super);

  function Food(x, y, map) {
    this.map = map;
    Food.__super__.constructor.apply(this, arguments);
    this.width = Math.ceil(Map.tileWidth / 10);
    this.height = Math.ceil(Map.tileHeight / 10);
    this.boundingBox = new Rectangle(this.position, this.width, this.height);
    this.eated = false;
  }

  Food.prototype.getEaten = function() {
    return this.eated = true;
  };

  Food.prototype.draw = function(context) {
    if (!this.eated) {
      context.fillStyle = "#FFF";
      context.beginPath();
      return context.fillRect(this.position.x - (this.width / 2), this.position.y - (this.height / 2), this.width, this.height);
    }
  };

  Food.prototype.reset = function() {
    this.eated = false;
    return this.includeIntoTiles();
  };

  return Food;

})(Entity);

Player = (function(_super) {

  __extends(Player, _super);

  function Player(x, y, map, options) {
    var _ref;
    this.map = map;
    if (options == null) {
      options = {};
    }
    Player.__super__.constructor.apply(this, arguments);
    if ((_ref = options.direction) == null) {
      options.direction = "left";
    }
    this.direction = new Direction(options.direction);
    this.initialDirection = new Direction(options.direction);
    this.intentDirection = new Direction;
    this.speed = 6;
    this.frozen = true;
    this.status = "alive";
  }

  Player.prototype.calculateDisplacement = function(gameFps) {
    return this.displacement = this.frozen ? 0 : (this.speed * (Map.tileWidth + Map.tileHeight) / 2) / gameFps;
  };

  Player.prototype.tilesAhead = function(direction) {
    var position, positionsAhead, _i, _len, _ref;
    if (direction == null) {
      direction = this.direction;
    }
    positionsAhead = [];
    _ref = this.boundingBox.toArray();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      position = _ref[_i];
      position.x += this.displacement * direction.toCoordinate().x;
      position.y += this.displacement * direction.toCoordinate().y;
      positionsAhead.push(position);
    }
    return this.currentTiles(positionsAhead);
  };

  Player.prototype.canMove = function(direction) {
    if (direction == null) {
      direction = this.direction;
    }
    return !_.any(this.tilesAhead(direction), function(tile) {
      return (tile != null ? tile.isWall() : void 0) || (tile != null ? tile.isGhostWall() : void 0);
    });
  };

  Player.prototype.turnLeft = function() {
    return this.intentDirection.set("left");
  };

  Player.prototype.turnRight = function() {
    return this.intentDirection.set("right");
  };

  Player.prototype.turnUp = function() {
    return this.intentDirection.set("up");
  };

  Player.prototype.turnDown = function() {
    return this.intentDirection.set("down");
  };

  Player.prototype.canChangeDirection = function() {
    return this.canMove(this.intentDirection) && _.any(this.tilesAhead(this.intentDirection), function(tile) {
      return !!tile;
    });
  };

  Player.prototype.updateDirection = function() {
    if ((this.intentDirection.angle != null) && this.canChangeDirection()) {
      this.direction.set(this.intentDirection.angle);
      this.intentDirection.set(null);
    }
    return this.direction;
  };

  Player.prototype.updatePosition = function() {
    var tileCenter, _ref;
    this.excludeFromTiles();
    if (_.all(this.currentTiles(), function(tile) {
      return !tile;
    })) {
      this.position.x -= this.map.width - Map.tileWidth / 10;
      if (this.position.x < 0) {
        this.position.x = parseInt(this.position.x.toString().replace("-", ""));
      } else {
        this.position.x -= Map.tileWidth;
      }
    } else if (this.canMove()) {
      this.previousPosition = _.clone(this.position);
      this.position.x += this.direction.toCoordinate().x * this.displacement;
      this.position.y += this.direction.toCoordinate().y * this.displacement;
      tileCenter = (_ref = this.currentTiles(this.position)[0]) != null ? _ref.centerCoordinate() : void 0;
      if ((tileCenter != null ? tileCenter.betweenAxis(this.position, this.previousPosition) : void 0) || !this.canMove()) {
        this.position.set(tileCenter.x, tileCenter.y);
      }
      delete this.previousPosition;
    }
    this.includeIntoTiles();
    return this.position;
  };

  Player.prototype.freeze = function() {
    return this.frozen = true;
  };

  Player.prototype.unfreeze = function() {
    return this.frozen = false;
  };

  Player.prototype.live = function() {
    return this.status = "alive";
  };

  Player.prototype.isAlive = function() {
    return this.status === "alive";
  };

  Player.prototype.isDead = function() {
    return this.status === "dead";
  };

  Player.prototype.collidesWith = function(entity) {};

  Player.prototype.update = function(gameFps) {
    this.calculateDisplacement(gameFps);
    if (!this.frozen) {
      this.updateDirection();
      return this.updatePosition();
    }
  };

  Player.prototype.draw = function(context) {};

  Player.prototype.drawPosition = function(context) {
    context.font = "bold 12px sans-serif";
    context.textAlign = "center";
    context.fillStyle = "#FFF";
    return context.fillText("(" + Math.ceil(this.position.x) + ", " + Math.ceil(this.position.y) + ")", this.position.x, this.position.y - Map.tileHeight);
  };

  Player.prototype.reset = function() {
    this.excludeFromTiles();
    this.position.set(this.initialPosition);
    this.direction.set(this.initialDirection);
    this.renderer.reset();
    this.includeIntoTiles();
    return this.live();
  };

  return Player;

})(Entity);

Pacman = (function(_super) {

  __extends(Pacman, _super);

  function Pacman() {
    return Pacman.__super__.constructor.apply(this, arguments);
  }

  Pacman.prototype.collidesWith = function(entity) {
    if (entity instanceof Food) {
      return this.collidesWithFood(entity);
    }
  };

  Pacman.prototype.collidesWithFood = function(food) {
    food.excludeFromTiles();
    return food.getEaten();
  };

  Pacman.prototype.getCaught = function() {
    if (this.isAlive()) {
      this.status = "caught";
      return this.freeze();
    }
  };

  Pacman.prototype.gotCaught = function() {
    return this.status === "caught";
  };

  Pacman.prototype.die = function() {
    if (this.gotCaught()) {
      this.status = "dead";
      this.renderer.frame = 0;
      return this.unfreeze();
    }
  };

  Pacman.prototype.update = function(gameFps) {
    this.calculateDisplacement(gameFps);
    if (!this.frozen && !this.isDead()) {
      this.updateDirection();
      return this.updatePosition();
    }
  };

  Pacman.prototype.draw = function(context) {
    var _ref;
    if ((_ref = this.renderer) == null) {
      this.renderer = new PacmanRenderer(context, this);
    }
    return this.renderer.draw();
  };

  return Pacman;

})(Player);

Ghost = (function(_super) {

  __extends(Ghost, _super);

  function Ghost(x, y, map, options) {
    this.map = map;
    Ghost.__super__.constructor.apply(this, arguments);
    this.color = options.color;
  }

  Ghost.prototype.canMove = function(direction) {
    if (direction == null) {
      direction = this.direction;
    }
    return !_.any(this.tilesAhead(direction), function(tile) {
      return tile != null ? tile.isWall() : void 0;
    });
  };

  Ghost.prototype.collidesWith = function(entity) {
    if (entity instanceof Pacman) {
      return this.collidesWithPacman(entity);
    }
  };

  Ghost.prototype.collidesWithPacman = function(pacman) {
    return pacman.getCaught();
  };

  Ghost.prototype.draw = function(context) {
    var _ref;
    if ((_ref = this.renderer) == null) {
      this.renderer = new GhostRenderer(context, this);
    }
    return this.renderer.draw();
  };

  return Ghost;

})(Player);

PlayerRenderer = (function() {

  function PlayerRenderer(context, player, options) {
    this.context = context;
    this.player = player;
    if (options == null) {
      options = {};
    }
    this.radius = options.radius || (Map.tileWidth + (Map.wallPadding / 2)) / 2;
    this.frame = 0;
  }

  PlayerRenderer.prototype.draw = function() {};

  PlayerRenderer.prototype.reset = function() {};

  return PlayerRenderer;

})();

PacmanRenderer = (function(_super) {

  __extends(PacmanRenderer, _super);

  function PacmanRenderer(context, player) {
    var _this = this;
    this.context = context;
    this.player = player;
    PacmanRenderer.__super__.constructor.apply(this, arguments);
    this.frame = 3;
    this.frames = [
      function() {
        return _this.context.arc(0, 0, _this.radius, 0, Math.PI * 2, true);
      }, function() {
        return _this.context.arc(0, 0, _this.radius, Math.PI * 0.1, Math.PI * 1.9, false);
      }, function() {
        return _this.context.arc(0, 0, _this.radius, Math.PI * 0.2, Math.PI * 1.8, false);
      }, function() {
        return _this.context.arc(0, 0, _this.radius, Math.PI * 0.3, Math.PI * 1.7, false);
      }, function() {
        return _this.context.arc(0, 0, _this.radius, Math.PI * 0.4, Math.PI * 1.6, false);
      }, function() {
        return _this.context.arc(0, 0, _this.radius, Math.PI * 0.5, Math.PI * 1.5, false);
      }, function() {
        return _this.context.arc(0, 0, _this.radius, Math.PI * 0.6, Math.PI * 1.4, false);
      }, function() {
        return _this.context.arc(0, 0, _this.radius, Math.PI * 0.7, Math.PI * 1.3, false);
      }, function() {
        return _this.context.arc(0, 0, _this.radius, Math.PI * 0.8, Math.PI * 1.2, false);
      }, function() {
        return _this.context.arc(0, 0, _this.radius, Math.PI * 0.9, Math.PI * 1.1, false);
      }, function() {
        return _this.context.arc(0, 0, _this.radius, Math.PI, Math.PI, false);
      }
    ];
    this.aliveFrames = [this.frames[3], this.frames[2], this.frames[1], this.frames[0], this.frames[1], this.frames[2], this.frames[3]];
  }

  PacmanRenderer.prototype.draw = function() {
    var _ref, _ref1;
    this.context.beginPath();
    this.context.fillStyle = "#FF0";
    this.context.save();
    this.context.translate(this.player.position.x, this.player.position.y);
    this.context.rotate(this.player.direction.angle);
    if (this.player.isDead()) {
      if ((_ref = this.dyingAnimationTimer) == null) {
        this.dyingAnimationTimer = new Timer(60);
      }
      if (this.dyingAnimationTimer.timeOver()) {
        if (this.frames[this.frame + 1] != null) {
          this.frame += 1;
        }
        delete this.dyingAnimationTimer;
      }
      this.frames[this.frame]();
    } else {
      if (!this.player.frozen) {
        if ((_ref1 = this.aliveAnimationTimer) == null) {
          this.aliveAnimationTimer = new Timer(30);
        }
        if (this.aliveAnimationTimer.timeOver()) {
          this.frame += 1;
          if (this.aliveFrames[this.frame] == null) {
            this.frame = 0;
          }
          delete this.aliveAnimationTimer;
        }
        if (this.player.isAlive() && !this.player.canMove()) {
          this.frame = 1;
        }
      }
      this.aliveFrames[this.frame]();
    }
    this.context.lineTo(-(this.radius / 4), 0);
    this.context.fill();
    return this.context.restore();
  };

  PacmanRenderer.prototype.drawLifes = function(lifes) {
    var y,
      _this = this;
    y = (Map.tileHeight * MAPS_MATRIX[0].length) - this.radius;
    return _.times(lifes, function(n) {
      var x;
      x = (Map.tileWidth * MAPS_MATRIX[0][0].length) - (n * Map.tileWidth) - _this.radius;
      _this.context.save();
      _this.context.translate(x, y);
      _this.context.scale(0.65, 0.65);
      _this.context.beginPath();
      _this.context.fillStyle = "#FF0";
      _this.frames[2]();
      _this.context.lineTo(-(_this.radius / 4), 0);
      _this.context.fill();
      return _this.context.restore();
    });
  };

  PacmanRenderer.prototype.reset = function() {
    return this.frame = 3;
  };

  return PacmanRenderer;

})(PlayerRenderer);

GhostRenderer = (function(_super) {

  __extends(GhostRenderer, _super);

  function GhostRenderer(context, player) {
    this.context = context;
    this.player = player;
    GhostRenderer.__super__.constructor.apply(this, arguments);
    this.animationTimer = new Timer(200);
  }

  GhostRenderer.prototype.draw = function() {
    var color;
    if (this.player.status === "alive" || this.player.status === "vulnerable") {
      color = this.player.status === "vulnerable" ? "#0038F8" : this.player.color;
      this.drawBody(color);
      this.drawBottomBody(color);
    }
    if (this.player.status === "alive" || this.player.status === "dead") {
      this.drawEyeBalls();
      return this.drawPupils();
    } else {
      this.drawVulnerableEyes();
      return this.drawVulnerableMouth();
    }
  };

  GhostRenderer.prototype.drawEyeBalls = function() {
    if (this.player.direction.toString() === "left") {
      this.drawEyeBall(this.player.position.x - (this.radius * 5 / 8), this.player.position.y - (this.radius * 4 / 8));
      return this.drawEyeBall(this.player.position.x + (this.radius * 1 / 8), this.player.position.y - (this.radius * 4 / 8));
    } else if (this.player.direction.toString() === "right") {
      this.drawEyeBall(this.player.position.x - (this.radius * 1 / 8), this.player.position.y - (this.radius * 4 / 8));
      return this.drawEyeBall(this.player.position.x + (this.radius * 5 / 8), this.player.position.y - (this.radius * 4 / 8));
    } else if (this.player.direction.toString() === "up") {
      this.drawEyeBall(this.player.position.x - (this.radius * 3 / 8), this.player.position.y - (this.radius * 7 / 8));
      return this.drawEyeBall(this.player.position.x + (this.radius * 3 / 8), this.player.position.y - (this.radius * 7 / 8));
    } else if (this.player.direction.toString() === "down") {
      this.drawEyeBall(this.player.position.x - (this.radius * 3 / 8), this.player.position.y - (this.radius * 4 / 8));
      return this.drawEyeBall(this.player.position.x + (this.radius * 3 / 8), this.player.position.y - (this.radius * 4 / 8));
    }
  };

  GhostRenderer.prototype.drawEyeBall = function(x, y) {
    this.context.beginPath();
    this.context.fillStyle = "#FFF";
    this.context.moveTo(x, y);
    this.context.bezierCurveTo(x - (this.radius * 3 / 8), y, x - (this.radius * 3 / 8), y + (this.radius * 6 / 8), x, y + (this.radius * 6 / 8));
    this.context.bezierCurveTo(x + (this.radius * 3 / 8), y + (this.radius * 6 / 8), x + (this.radius * 3 / 8), y, x, y);
    return this.context.fill();
  };

  GhostRenderer.prototype.drawPupils = function() {
    if (this.player.direction.toString() === "left") {
      this.drawPupil(this.player.position.x - (this.radius * 6 / 8), this.player.position.y - (this.radius * 1 / 8));
      return this.drawPupil(this.player.position.x, this.player.position.y - (this.radius * 1 / 8));
    } else if (this.player.direction.toString() === "right") {
      this.drawPupil(this.player.position.x, this.player.position.y - (this.radius * 1 / 8));
      return this.drawPupil(this.player.position.x + (this.radius * 6 / 8), this.player.position.y - (this.radius * 1 / 8));
    } else if (this.player.direction.toString() === "up") {
      this.drawPupil(this.player.position.x - (this.radius * 3 / 8), this.player.position.y - (this.radius * 6 / 8));
      return this.drawPupil(this.player.position.x + (this.radius * 3 / 8), this.player.position.y - (this.radius * 6 / 8));
    } else if (this.player.direction.toString() === "down") {
      this.drawPupil(this.player.position.x - (this.radius * 3 / 8), this.player.position.y + (this.radius * 1 / 8));
      return this.drawPupil(this.player.position.x + (this.radius * 3 / 8), this.player.position.y + (this.radius * 1 / 8));
    }
  };

  GhostRenderer.prototype.drawPupil = function(x, y) {
    this.context.beginPath();
    this.context.fillStyle = "#3000FF";
    this.context.arc(x, y, this.radius * 1 / 8, 0, Math.PI * 2, false);
    return this.context.fill();
  };

  GhostRenderer.prototype.drawVulnerableEyes = function() {
    this.context.save();
    this.context.translate(this.player.position.x, this.player.position.y);
    this.context.beginPath();
    this.context.fillStyle = "#F4BF3B";
    this.context.arc(-(this.radius * 3 / 8), -(this.radius * 1 / 8), this.radius * 1 / 6, 0, Math.PI * 2, false);
    this.context.arc(this.radius * 3 / 8, -(this.radius * 1 / 8), this.radius * 1 / 6, 0, Math.PI * 2, false);
    this.context.fill();
    return this.context.restore();
  };

  GhostRenderer.prototype.drawVulnerableMouth = function() {
    var radius;
    this.context.save();
    this.context.translate(this.player.position.x, this.player.position.y);
    this.context.strokeStyle = "#F4BF3B";
    radius = this.radius * 1 / 6;
    this.context.beginPath();
    this.context.arc(-(this.radius * 4 / 8), this.radius * 3 / 6, radius, 0, Math.PI, true);
    this.context.stroke();
    this.context.beginPath();
    this.context.arc(-(this.radius * 2 / 8), this.radius * 2 / 6, radius, 0, Math.PI, false);
    this.context.stroke();
    this.context.beginPath();
    this.context.arc(0, this.radius * 3 / 6, radius, 0, Math.PI, true);
    this.context.stroke();
    this.context.beginPath();
    this.context.arc(this.radius * 2 / 8, this.radius * 2 / 6, radius, 0, Math.PI, false);
    this.context.stroke();
    this.context.beginPath();
    this.context.arc(this.radius * 4 / 8, this.radius * 3 / 6, radius, 0, Math.PI, true);
    this.context.stroke();
    return this.context.restore();
  };

  GhostRenderer.prototype.drawBody = function(color) {
    this.context.fillStyle = color;
    this.context.strokeStyle = color;
    this.context.beginPath();
    this.context.arc(this.player.position.x, this.player.position.y, this.radius, 0, Math.PI, true);
    this.context.stroke();
    this.context.fill();
    this.context.fillRect(this.player.position.x - this.radius, this.player.position.y - 1, this.radius * 2, (this.radius * 2 / 3) + 1);
    return this.context.strokeRect(this.player.position.x - this.radius, this.player.position.y - 1, this.radius * 2, (this.radius * 2 / 3) + 1);
  };

  GhostRenderer.prototype.drawBottomBody = function(color) {
    var bottomBodyFrames,
      _this = this;
    this.context.strokeStyle = color;
    this.context.fillStyle = color;
    this.context.beginPath();
    this.context.moveTo(this.player.position.x - this.radius, this.player.position.y + (this.radius * 2 / 3));
    bottomBodyFrames = [];
    bottomBodyFrames[0] = function() {
      var cpx, cpy;
      cpx = _this.player.position.x - (_this.radius * 2 / 3);
      cpy = _this.player.position.y + (_this.radius * 1.2);
      _this.context.bezierCurveTo(cpx, cpy, cpx, cpy, _this.player.position.x - (_this.radius * 1 / 3), _this.player.position.y + (_this.radius * 2 / 3));
      cpx = _this.player.position.x;
      cpy = _this.player.position.y + (_this.radius * 1.2);
      _this.context.bezierCurveTo(cpx, cpy, cpx, cpy, _this.player.position.x + (_this.radius * 1 / 3), _this.player.position.y + (_this.radius * 2 / 3));
      cpx = _this.player.position.x + (_this.radius * 2 / 3);
      cpy = _this.player.position.y + (_this.radius * 1.2);
      _this.context.bezierCurveTo(cpx, cpy, cpx, cpy, _this.player.position.x + _this.radius, _this.player.position.y + (_this.radius * 2 / 3));
      return _this.context.lineTo(_this.player.position.x - _this.radius, _this.player.position.y + (_this.radius * 2 / 3));
    };
    bottomBodyFrames[1] = function() {
      var cpx, cpy;
      _this.context.lineTo(_this.player.position.x - _this.radius, _this.player.position.y + _this.radius);
      _this.context.lineTo(_this.player.position.x - (_this.radius * 2 / 3), _this.player.position.y + (_this.radius * 2 / 3));
      cpx = _this.player.position.x - (_this.radius * 1 / 6);
      cpy = _this.player.position.y + (_this.radius * 1.2);
      _this.context.bezierCurveTo(cpx, cpy, cpx, cpy, _this.player.position.x - (_this.radius * 1 / 6), _this.player.position.y + (_this.radius * 2 / 3));
      _this.context.lineTo(_this.player.position.x + (_this.radius * 1 / 6), _this.player.position.y + (_this.radius * 2 / 3));
      cpx = _this.player.position.x + (_this.radius * 1 / 6);
      _this.context.bezierCurveTo(cpx, cpy, cpx, cpy, _this.player.position.x + (_this.radius * 2 / 3), _this.player.position.y + (_this.radius * 2 / 3));
      _this.context.lineTo(_this.player.position.x + _this.radius, _this.player.position.y + _this.radius);
      _this.context.lineTo(_this.player.position.x + _this.radius, _this.player.position.y + (_this.radius * 2 / 3));
      return _this.context.lineTo(_this.player.position.x - _this.radius, _this.player.position.y + (_this.radius * 2 / 3));
    };
    if (this.player.frozen || !this.player.canMove()) {
      this.frame = 0;
    } else if (this.animationTimer.timeOver()) {
      this.frame += 1;
      if (bottomBodyFrames[this.frame] == null) {
        this.frame = 0;
      }
      this.animationTimer.reset();
    }
    bottomBodyFrames[this.frame]();
    this.context.stroke();
    return this.context.fill();
  };

  return GhostRenderer;

})(PlayerRenderer);

Tile = (function() {

  function Tile(map, i, j, type) {
    this.map = map;
    this.i = i;
    this.j = j;
    this.type = type;
    this.entities = [];
  }

  Tile.prototype.centerCoordinate = function() {
    var x, y;
    x = (this.j * Map.tileWidth) + (Map.tileWidth / 2);
    y = (this.i * Map.tileHeight) + (Map.tileHeight / 2);
    return new Coordinate(x, y);
  };

  Tile.prototype.above = function() {
    var _ref;
    return (_ref = this.map.tiles[this.i - 1]) != null ? _ref[this.j] : void 0;
  };

  Tile.prototype.aboveRight = function() {
    var _ref;
    return (_ref = this.map.tiles[this.i - 1]) != null ? _ref[this.j + 1] : void 0;
  };

  Tile.prototype.right = function() {
    return this.map.tiles[this.i][this.j + 1];
  };

  Tile.prototype.belowRight = function() {
    var _ref;
    return (_ref = this.map.tiles[this.i + 1]) != null ? _ref[this.j + 1] : void 0;
  };

  Tile.prototype.below = function() {
    var _ref;
    return (_ref = this.map.tiles[this.i + 1]) != null ? _ref[this.j] : void 0;
  };

  Tile.prototype.belowLeft = function() {
    var _ref;
    return (_ref = this.map.tiles[this.i + 1]) != null ? _ref[this.j - 1] : void 0;
  };

  Tile.prototype.left = function() {
    return this.map.tiles[this.i][this.j - 1];
  };

  Tile.prototype.aboveLeft = function() {
    var _ref;
    return (_ref = this.map.tiles[this.i - 1]) != null ? _ref[this.j - 1] : void 0;
  };

  Tile.prototype.isWall = function(wallType) {
    if (wallType == null) {
      wallType = Map.WALL;
    }
    return this.type === wallType;
  };

  Tile.prototype.isGhostWall = function() {
    return this.isWall(Map.GHOST_WALL);
  };

  Tile.prototype.isPath = function() {
    return this.type === Map.PATH;
  };

  Tile.prototype.isWallUpCorner = function(wallType) {
    var _ref, _ref1;
    if (wallType == null) {
      wallType = Map.WALL;
    }
    return ((_ref = this.above()) != null ? _ref.isPath() : void 0) && ((_ref1 = this.below()) != null ? _ref1.isWall(wallType) : void 0);
  };

  Tile.prototype.isWallRightCorner = function(wallType) {
    var _ref, _ref1;
    if (wallType == null) {
      wallType = Map.WALL;
    }
    return ((_ref = this.right()) != null ? _ref.isPath() : void 0) && ((_ref1 = this.left()) != null ? _ref1.isWall(wallType) : void 0);
  };

  Tile.prototype.isWallDownCorner = function(wallType) {
    var _ref, _ref1;
    if (wallType == null) {
      wallType = Map.WALL;
    }
    return ((_ref = this.below()) != null ? _ref.isPath() : void 0) && ((_ref1 = this.above()) != null ? _ref1.isWall(wallType) : void 0);
  };

  Tile.prototype.isWallLeftCorner = function(wallType) {
    var _ref, _ref1;
    if (wallType == null) {
      wallType = Map.WALL;
    }
    return ((_ref = this.left()) != null ? _ref.isPath() : void 0) && ((_ref1 = this.right()) != null ? _ref1.isWall(wallType) : void 0);
  };

  return Tile;

})();

MAPS_MATRIX = [];

MAPS_MATRIX[0] = [['w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w'], ['w', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'w', 'w', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'w'], ['w', 'f', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'f', 'w'], ['w', 'f', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'f', 'w'], ['w', 'f', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'f', 'w'], ['w', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'w'], ['w', 'f', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'f', 'w'], ['w', 'f', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'f', 'w'], ['w', 'f', 'f', 'f', 'f', 'f', 'f', 'w', 'w', 'f', 'f', 'f', 'f', 'w', 'w', 'f', 'f', 'f', 'f', 'w', 'w', 'f', 'f', 'f', 'f', 'f', 'f', 'w'], ['w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'p', 'w', 'w', 'p', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w'], ['w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'p', 'w', 'w', 'p', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w'], ['w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w'], ['w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'p', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'p', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w'], ['w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'p', 'g', 'g', 'G', 'g', 'g', 'G', 'g', 'g', 'p', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w'], ['p', 'p', 'p', 'p', 'p', 'p', 'f', 'p', 'p', 'p', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'p', 'p', 'p', 'f', 'p', 'p', 'p', 'p', 'p', 'p'], ['w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'p', 'g', 'g', 'G', 'g', 'g', 'G', 'g', 'g', 'p', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w'], ['w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'p', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'p', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w'], ['w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w'], ['w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'p', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'p', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w'], ['w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'p', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'p', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w'], ['w', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'w', 'w', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'w'], ['w', 'f', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'f', 'w'], ['w', 'f', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'f', 'w'], ['w', 'f', 'f', 'f', 'w', 'w', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'P', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'w', 'w', 'f', 'f', 'f', 'w'], ['w', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'w'], ['w', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'w'], ['w', 'f', 'f', 'f', 'f', 'f', 'f', 'w', 'w', 'f', 'f', 'f', 'f', 'w', 'w', 'f', 'f', 'f', 'f', 'w', 'w', 'f', 'f', 'f', 'f', 'f', 'f', 'w'], ['w', 'f', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'f', 'w'], ['w', 'f', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'f', 'w', 'w', 'f', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'f', 'w'], ['w', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'f', 'w'], ['w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w'], ['w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w', 'w']];

MAPS_MATRIX[1] = [['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'P', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p']];

Map = (function() {

  Map.tileWidth = 20;

  Map.tileHeight = 20;

  Map.wallPadding = 10;

  Map.WALL = "w";

  Map.GHOST_WALL = "g";

  Map.PATH = "p";

  Map.FOOD = "f";

  Map.PACMAN = "P";

  Map.GHOST = "G";

  function Map(options) {
    var array, food, ghost, ghostAttributes, i, j, mapIndex, value, x, y, _i, _j, _len, _len1, _ref;
    if (options == null) {
      options = {};
    }
    mapIndex = options.mapIndex || 0;
    this.matrix = MAPS_MATRIX[mapIndex];
    Map.tileHeight = Math.floor(window.innerHeight / this.matrix.length);
    Map.tileWidth = Map.tileHeight;
    Map.wallPadding = Map.tileHeight / 2;
    this.width = this.matrix[0].length * Map.tileWidth;
    this.height = this.matrix.length * Map.tileHeight;
    this.tiles = [];
    this.entities = {
      characters: [],
      foods: []
    };
    ghostAttributes = {
      colors: ["#F81F17", "#48FEFE", "#FB9DCD", "#FACE26"],
      initialDirections: ["up", "right", "left", "down"]
    };
    _ref = this.matrix;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      array = _ref[i];
      this.tiles[i] = [];
      for (j = _j = 0, _len1 = array.length; _j < _len1; j = ++_j) {
        value = array[j];
        this.tiles[i][j] = new Tile(this, i, j, value);
        x = this.tiles[i][j].centerCoordinate().x;
        y = this.tiles[i][j].centerCoordinate().y;
        if (value === Map.FOOD) {
          food = new Food(x, y, this);
          this.tiles[i][j].type = Map.PATH;
          this.tiles[i][j].entities.push(food);
          this.entities.foods.push(food);
        }
        if (value === Map.PACMAN) {
          this.tiles[i][j].type = Map.PATH;
          this.entities.characters.push(new Pacman(x, y, this));
          this.entities.characters.reverse();
        }
        if (value === Map.GHOST) {
          this.tiles[i][j].type = Map.GHOST_WALL;
          options = {
            color: ghostAttributes.colors.shift(),
            direction: ghostAttributes.initialDirections.shift()
          };
          ghost = new Ghost(x, y, this, options);
          this.entities.characters.push(ghost);
        }
      }
    }
  }

  Map.prototype.remainingFoods = function() {
    return _.filter(this.entities.foods, function(food) {
      return !food.eated;
    });
  };

  Map.prototype.draw = function(context) {
    this.drawWalls(context);
    return this.drawGhostWalls(context);
  };

  Map.prototype.drawWalls = function(context) {
    context.beginPath();
    this.drawLines(context);
    context.closePath();
    context.strokeStyle = "#03F";
    context.lineWidth = 2;
    return context.stroke();
  };

  Map.prototype.drawGhostWalls = function(context) {
    context.beginPath();
    this.drawLines(context, Map.GHOST_WALL);
    context.closePath();
    context.strokeStyle = "#EEACA9";
    context.lineWidth = 2;
    return context.stroke();
  };

  Map.prototype.drawLines = function(context, wallType) {
    var array, endX, endY, i, j, startX, startY, tile, value, x, y, _i, _len, _ref, _results, _x, _y;
    if (wallType == null) {
      wallType = Map.WALL;
    }
    _ref = this.matrix;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      array = _ref[i];
      _results.push((function() {
        var _j, _len1, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _results1;
        _results1 = [];
        for (j = _j = 0, _len1 = array.length; _j < _len1; j = ++_j) {
          value = array[j];
          x = j * Map.tileWidth;
          y = i * Map.tileHeight;
          tile = this.tiles[i][j];
          if (tile.isWall(wallType)) {
            startX = tile.isWallLeftCorner(wallType) ? x + Map.wallPadding : x;
            endX = tile.isWallRightCorner(wallType) ? x + Map.tileWidth - Map.wallPadding : x + Map.tileWidth;
            startY = tile.isWallUpCorner(wallType) ? y + Map.wallPadding : y;
            endY = tile.isWallDownCorner(wallType) ? y + Map.tileHeight - Map.wallPadding : y + Map.tileHeight;
            if ((_ref1 = tile.above()) != null ? _ref1.isPath() : void 0) {
              _y = y + Map.wallPadding + 0.5;
              context.moveTo(startX, _y);
              context.lineTo(endX, _y);
            }
            if ((_ref2 = tile.right()) != null ? _ref2.isPath() : void 0) {
              _x = x + Map.tileWidth - Map.wallPadding - 0.5;
              context.moveTo(_x, startY);
              context.lineTo(_x, endY);
            }
            if ((_ref3 = tile.below()) != null ? _ref3.isPath() : void 0) {
              _y = y + Map.tileHeight - Map.wallPadding - 0.5;
              context.moveTo(startX, _y);
              context.lineTo(endX, _y);
            }
            if ((_ref4 = tile.left()) != null ? _ref4.isPath() : void 0) {
              _x = x + Map.wallPadding + 0.5;
              context.moveTo(_x, startY);
              context.lineTo(_x, endY);
            }
            if ((((_ref5 = tile.above()) != null ? _ref5.isWall(wallType) : void 0) || !(tile.above() != null)) && (((_ref6 = tile.right()) != null ? _ref6.isWall(wallType) : void 0) || !(tile.right() != null)) && (((_ref7 = tile.below()) != null ? _ref7.isWall(wallType) : void 0) || !(tile.below() != null)) && (((_ref8 = tile.left()) != null ? _ref8.isWall(wallType) : void 0) || !(tile.left() != null))) {
              if ((_ref9 = tile.aboveRight()) != null ? _ref9.isPath() : void 0) {
                context.moveTo(x + Map.tileWidth, y + Map.wallPadding + 0.5);
                context.lineTo(x + Map.tileWidth - Map.wallPadding - 0.5, y + Map.wallPadding + 0.5);
                context.lineTo(x + Map.tileWidth - Map.wallPadding - 0.5, y);
              }
              if ((_ref10 = tile.belowRight()) != null ? _ref10.isPath() : void 0) {
                context.moveTo(x + Map.tileWidth, y + Map.tileHeight - Map.wallPadding - 0.5);
                context.lineTo(x + Map.tileWidth - Map.wallPadding - 0.5, y + Map.tileHeight - Map.wallPadding - 0.5);
                context.lineTo(x + Map.tileWidth - Map.wallPadding - 0.5, y + Map.tileHeight);
              }
              if ((_ref11 = tile.belowLeft()) != null ? _ref11.isPath() : void 0) {
                context.moveTo(x, y + Map.tileHeight - Map.wallPadding - 0.5);
                context.lineTo(x + Map.wallPadding + 0.5, y + Map.tileHeight - Map.wallPadding - 0.5);
                context.lineTo(x + Map.wallPadding + 0.5, y + Map.tileHeight);
              }
              if ((_ref12 = tile.aboveLeft()) != null ? _ref12.isPath() : void 0) {
                context.moveTo(x, y + Map.wallPadding + 0.5);
                context.lineTo(x + Map.wallPadding + 0.5, y + Map.wallPadding + 0.5);
                _results1.push(context.lineTo(x + Map.wallPadding + 0.5, y));
              } else {
                _results1.push(void 0);
              }
            } else {
              _results1.push(void 0);
            }
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Map.prototype.drawGrid = function(context) {
    var array, i, j, value, x, y, _i, _len, _ref, _results;
    context.beginPath();
    context.lineWidth = 1;
    _ref = this.matrix;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      array = _ref[i];
      _results.push((function() {
        var _j, _len1, _results1;
        _results1 = [];
        for (j = _j = 0, _len1 = array.length; _j < _len1; j = ++_j) {
          value = array[j];
          x = j * Map.tileWidth;
          y = i * Map.tileHeight;
          context.moveTo(x, y + Map.tileHeight + 0.5);
          context.lineTo(x + Map.tileWidth, y + Map.tileHeight + 0.5);
          context.moveTo(x + Map.tileWidth + 0.5, y);
          context.lineTo(x + Map.tileWidth + 0.5, y + Map.tileHeight);
          context.closePath();
          context.strokeStyle = "#444";
          context.stroke();
          context.font = "bold 12px sans-serif";
          context.textBaseline = "middle";
          context.fillStyle = "#FFF";
          if (j === 0) {
            context.textAlign = "left";
            context.fillText(i, x, y + (Map.tileHeight / 2));
          }
          if (i === 0) {
            context.textAlign = "center";
            _results1.push(context.fillText(j, x + (Map.tileWidth / 2), y + 6));
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  Map.prototype.drawTilesType = function(context) {
    var array, i, j, value, x, y, _i, _len, _ref, _results;
    context.font = "bold 14px menlo";
    context.textAlign = "center";
    context.textBaseline = "middle";
    context.fillStyle = "#FFF";
    _ref = this.matrix;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      array = _ref[i];
      _results.push((function() {
        var _j, _len1, _results1;
        _results1 = [];
        for (j = _j = 0, _len1 = array.length; _j < _len1; j = ++_j) {
          value = array[j];
          if (value === "f" || value === "P") {
            value = "p";
          }
          if (value === "G") {
            value = "g";
          }
          x = (j * Map.tileWidth) + (Map.tileWidth / 2);
          y = (i * Map.tileHeight) + (Map.tileHeight / 2);
          _results1.push(context.fillText(value, x, y));
        }
        return _results1;
      })());
    }
    return _results;
  };

  return Map;

})();

Collider = (function() {

  function Collider(entities) {
    this.entities = entities;
  }

  Collider.prototype.makeCollisions = function() {
    var entity, player, tile, _i, _len, _ref, _results;
    _ref = this.entities.characters;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      player = _ref[_i];
      _results.push((function() {
        var _j, _len1, _ref1, _results1;
        _ref1 = player.currentTiles();
        _results1 = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          tile = _ref1[_j];
          if (tile) {
            _results1.push((function() {
              var _k, _len2, _ref2, _results2;
              _ref2 = tile.entities;
              _results2 = [];
              for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                entity = _ref2[_k];
                if (entity !== player) {
                  if (player.isIntersected(entity)) {
                    _results2.push(player.collidesWith(entity));
                  } else {
                    _results2.push(void 0);
                  }
                }
              }
              return _results2;
            })());
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  return Collider;

})();

Game = (function() {
  var MAX_FPS;

  MAX_FPS = 60;

  function Game() {
    this.tick = __bind(this.tick, this);

    this.setMessage = __bind(this.setMessage, this);

    this.setPlayerCharacter = __bind(this.setPlayerCharacter, this);

    this.handleKey = __bind(this.handleKey, this);

    var canvas, name, _i, _len, _ref;
    this.map = new Map;
    this.canvas = {};
    this.context = {};
    _ref = $("canvas");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      canvas = _ref[_i];
      name = canvas.id.replace("_canvas", "");
      this.canvas[name] = document.getElementById(canvas.id);
      this.canvas[name].width = this.map.matrix[0].length * Map.tileWidth;
      this.canvas[name].height = this.map.matrix.length * Map.tileHeight;
      this.context[name] = this.canvas[name].getContext("2d");
    }
    this.map.draw(this.context.map);
    this.characters = this.map.entities.characters;
    this.pacman = this.characters[0];
    this.foods = this.map.entities.foods;
    this.pacmanLifes = 3;
    this.collider = new Collider(this.map.entities);
    this.fpsTimer = new Timer(1000);
    this.message = "Wait";
    this.drawPacmanLifes();
    this.delay(2000);
    this.loop();
  }

  Game.prototype.calculateFps = function() {
    var _ref, _ref1;
    if ((_ref = this.framesCounter) == null) {
      this.framesCounter = 0;
    }
    if ((_ref1 = this.fps) == null) {
      this.fps = MAX_FPS;
    }
    if (this.fpsTimer.timeOver()) {
      this.fpsTimer.reset();
      this.fps = this.framesCounter;
      this.framesCounter = 0;
    }
    this.framesCounter += 1;
    return this.fps;
  };

  Game.prototype.handleKey = function(event, characterCode) {
    var keyCode, player;
    if (characterCode == null) {
      characterCode = this.characters.indexOf(this.player);
    }
    player = this.characters[characterCode];
    keyCode = player === this.player ? event.which : event;
    if (player === this.player && _.contains([37, 38, 39, 40], keyCode)) {
      socket.emit("keyPress", keyCode, this.characters.indexOf(this.player));
    }
    switch (keyCode) {
      case 37:
        return player.turnLeft();
      case 38:
        return player.turnUp();
      case 39:
        return player.turnRight();
      case 40:
        return player.turnDown();
    }
  };

  Game.prototype.setPlayerCharacter = function(characterCode) {
    return this.player = this.characters[characterCode];
  };

  Game.prototype.setMessage = function(message) {
    return this.message = message;
  };

  Game.prototype.play = function() {
    var character, _i, _len, _ref, _results;
    this.status = "running";
    this.message = "";
    _ref = this.characters;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      character = _ref[_i];
      _results.push(character.unfreeze());
    }
    return _results;
  };

  Game.prototype.freeze = function() {
    var character, _i, _len, _ref, _results;
    this.status = "frozen";
    _ref = this.characters;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      character = _ref[_i];
      _results.push(character.freeze());
    }
    return _results;
  };

  Game.prototype.end = function(winner) {
    this.status = "ended";
    this.message = "" + winner + " won";
    return this.drawPacmanLifes();
  };

  Game.prototype.isFrozen = function() {
    return this.status === "frozen";
  };

  Game.prototype.ended = function() {
    return this.status === "ended";
  };

  Game.prototype.delay = function(time, callback) {
    var _ref;
    if ((_ref = this.delayTimer) == null) {
      this.delayTimer = new Timer(time);
    }
    if (time) {
      this.delayTimer.setTime(time);
    }
    if (callback) {
      this.delayCallback = callback;
    }
    if (this.delayTimer.timeOver()) {
      this.play();
      if (this.delayCallback) {
        this.delayCallback();
        return delete this.delayCallback;
      }
    } else {
      return this.freeze();
    }
  };

  Game.prototype.reset = function() {
    var character, _i, _len, _ref;
    _ref = this.characters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      character = _ref[_i];
      character.reset();
    }
    this.message = "Wait";
    this.drawPacmanLifes();
    return this.delay(2000);
  };

  Game.prototype.update = function() {
    var character, _i, _len, _ref, _ref1;
    this.calculateFps();
    if (this.isFrozen()) {
      this.delay();
    }
    if (this.map.remainingFoods().length === 0) {
      return this.end("pacman");
    } else if (this.pacman.isAlive()) {
      _ref = this.characters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        character = _ref[_i];
        character.update(this.fps);
      }
      return this.collider.makeCollisions();
    } else if (this.pacman.gotCaught() && !this.isFrozen()) {
      return this.delay(2000, function() {
        return this.pacman.die();
      });
    } else if (this.pacman.isDead()) {
      if ((_ref1 = this.endMatchTimer) == null) {
        this.endMatchTimer = new Timer(4000);
      }
      if (this.endMatchTimer.timeOver()) {
        delete this.endMatchTimer;
        this.pacmanLifes -= 1;
        if (this.pacmanLifes > 0) {
          return this.reset();
        } else {
          return this.end("ghosts");
        }
      }
    }
  };

  Game.prototype.draw = function() {
    var food, player, _i, _j, _len, _len1, _ref, _ref1;
    this.canvas.player.width = this.canvas.player.width;
    _ref = this.foods;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      food = _ref[_i];
      food.draw(this.context.player);
    }
    _ref1 = this.characters;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      player = _ref1[_j];
      player.draw(this.context.player);
    }
    this.drawMessage();
    return this.drawFps();
  };

  Game.prototype.drawPacmanLifes = function() {
    var _ref;
    this.canvas.life.width = this.canvas.life.width;
    if ((_ref = this.pacmanRenderer) == null) {
      this.pacmanRenderer = new PacmanRenderer(this.context.life);
    }
    return this.pacmanRenderer.drawLifes(this.pacmanLifes);
  };

  Game.prototype.drawMessage = function() {
    var context, x, y;
    if (this.message) {
      x = 14 * Map.tileWidth;
      y = (17 * Map.tileHeight) + (Map.tileHeight / 2);
      context = this.context.player;
      context.font = "bold " + Map.tileHeight + "px sans-serif";
      context.textAlign = "center";
      context.textBaseline = "middle";
      context.fillStyle = "#FDFB4A";
      return context.fillText(this.message.toUpperCase(), x, y);
    }
  };

  Game.prototype.drawFps = function() {
    this.context.player.font = "bold 12px sans-serif";
    this.context.player.textAlign = "left";
    this.context.player.textBaseline = "bottom";
    this.context.player.fillStyle = "#FFF";
    return this.context.player.fillText("" + this.fps + " FPS", 5, this.canvas.map.height - 10);
  };

  Game.prototype.loop = function() {
    return requestAnimationFrame(this.tick);
  };

  Game.prototype.tick = function() {
    this.update();
    this.draw();
    if (!this.ended()) {
      return this.loop();
    }
  };

  return Game;

})();

BasicPlayer = (function() {

  function BasicPlayer(x, y, options) {
    var _ref;
    if (options == null) {
      options = {};
    }
    this.position = new Coordinate(x, y);
    if ((_ref = options.direction) == null) {
      options.direction = "left";
    }
    this.direction = new Direction(options.direction);
    this.status = options.status || "alive";
    this.frozen = options.frozen || false;
    this.color = options.color || "#FFF";
  }

  BasicPlayer.prototype.isAlive = function() {
    return this.status === "alive";
  };

  BasicPlayer.prototype.isDead = function() {
    return this.status === "dead";
  };

  BasicPlayer.prototype.canMove = function() {
    return true;
  };

  BasicPlayer.prototype.draw = function(renderer) {
    return renderer.draw();
  };

  return BasicPlayer;

})();

Slide = (function() {

  function Slide(presentation) {
    this.presentation = presentation;
    this.context = this.presentation.context;
    this.map = this.presentation.map;
    this.current = 0;
    this.slides = this.slides();
  }

  Slide.prototype.next = function() {
    if (this.slides[this.current + 1]) {
      this.current += 1;
    }
    return this.slides[this.current]();
  };

  Slide.prototype.previous = function() {
    if (this.slides[this.current - 1]) {
      this.current -= 1;
    }
    return this.slides[this.current]();
  };

  Slide.prototype.deleteGame = function() {
    if (this.game) {
      this.game.tick = function() {
        return false;
      };
      if (this.game) {
        return delete this.game;
      }
    }
  };

  Slide.prototype.writeTitle = function(text, options) {
    var fontSize;
    if (options == null) {
      options = {};
    }
    fontSize = options.fontSize ? Map.tileWidth * options.fontSize : Map.tileWidth * 2.8;
    this.context.map.beginPath();
    this.context.map.font = "bold " + fontSize + "px sans-serif";
    this.context.map.lineWidth = 2;
    this.context.map.textAlign = "center";
    this.context.map.strokeStyle = "#03F";
    this.context.map.fillStyle = "#FFF";
    this.context.map.fillText(text, this.map.width / 2, Map.tileHeight * 4);
    return this.context.map.closePath();
  };

  Slide.prototype.writeText = function(text, tileRow) {
    this.context.map.beginPath();
    this.context.map.font = "" + (Map.tileWidth * 1.4) + "px sans-serif";
    this.context.map.textAlign = "start";
    this.context.map.fillStyle = "#EEE";
    this.context.map.fillText(text, 0, Map.tileHeight * tileRow);
    return this.context.map.closePath();
  };

  Slide.prototype.draw = function() {
    return this.slides[this.current]();
  };

  Slide.prototype.drawIntegratorImage = function(n) {
    var image, imageHeight, imageWidth;
    if (n == null) {
      n = 1;
    }
    image = document.getElementById("integration_" + n);
    imageWidth = Map.tileWidth * 32;
    imageHeight = imageWidth * 0.75;
    return this.context.map.drawImage(image, (this.map.width / 2) - (imageWidth / 2), Map.tileHeight * 6, imageWidth, imageHeight);
  };

  Slide.prototype.slides = function() {
    var slides,
      _this = this;
    slides = [];
    slides[0] = function() {
      _this.context.map.beginPath();
      _this.context.map.font = "" + (Map.tileWidth * 2.8) + "px sans-serif";
      _this.context.map.textAlign = "center";
      _this.context.map.fillStyle = "#FFF";
      _this.context.map.strokeStyle = "#03F";
      _this.context.map.lineWidth = 2;
      _this.context.map.strokeText("JAVASCRIPT", _this.map.width / 2, Map.tileHeight * 7);
      _this.context.map.strokeText("PARA", _this.map.width / 2, Map.tileHeight * 12);
      _this.context.map.strokeText("DESENVOLVIMENTO", _this.map.width / 2, Map.tileHeight * 17);
      _this.context.map.strokeText("DE JOGOS", _this.map.width / 2, Map.tileHeight * 22);
      _this.context.map.closePath();
      _this.context.map.beginPath();
      _this.context.map.font = "" + (Map.tileWidth * 1.4) + "px sans-serif";
      _this.context.map.fillText("Marcelo Munhoz Pélos", _this.map.width / 2, Map.tileHeight * 27);
      return _this.context.map.closePath();
    };
    slides[1] = function() {
      return _this.writeTitle("Javascript");
    };
    slides[2] = function() {
      var browsersImage, imageHeight, imageWidth;
      _this.slides[1]();
      _this.writeText("● Implementado nativamente em todos os", 7);
      _this.writeText("navegadores", 9);
      browsersImage = document.getElementsByClassName("browsers")[0];
      imageWidth = Map.tileWidth * 14;
      imageHeight = Map.tileHeight * 14;
      return _this.context.map.drawImage(browsersImage, (_this.map.width / 2) - (imageWidth / 2), Map.tileHeight * 8, imageWidth, imageHeight);
    };
    slides[3] = function() {
      _this.slides[2]();
      return _this.writeText("● Multi-plataforma", 23);
    };
    slides[4] = function() {
      _this.slides[3]();
      return _this.writeText("● Usado para interação com HTML", 27);
    };
    slides[5] = function() {
      return _this.writeTitle("HTML 5 Canvas");
    };
    slides[6] = function() {
      _this.slides[5]();
      return _this.writeText("● Elemento para renderização gráfica", 9);
    };
    slides[7] = function() {
      _this.slides[6]();
      _this.writeText("● Manipulado utlizando a linguagem", 14);
      return _this.writeText("Javascript", 16);
    };
    slides[8] = function() {
      _this.slides[7]();
      _this.writeText("● Abriu portas para o desenvolvimento de", 21);
      return _this.writeText("jogos utilizando Javascript", 23);
    };
    slides[9] = function() {
      return _this.writeTitle("Jogos para Navegadores", {
        fontSize: 2.3
      });
    };
    slides[10] = function() {
      _this.slides[9]();
      _this.writeText("● Grande parcela dos jogos são", 10);
      return _this.writeText("desenvolvidos utilizando Adobe Flash", 12);
    };
    slides[11] = function() {
      _this.slides[10]();
      _this.writeText("● Quantidade de jogos desenvolvidos com", 17);
      _this.writeText("Javascript aumentam com a evolução do", 19);
      return _this.writeText("HTML 5", 21);
    };
    slides[12] = function() {
      return _this.writeTitle("Projeto Proposto");
    };
    slides[13] = function() {
      var textHeight, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      _this.slides[12]();
      textHeight = Map.tileHeight * 10;
      _this.context.map.beginPath();
      _this.context.map.font = "bold " + (Map.tileWidth * 4.8) + "px sans-serif";
      _this.context.map.textAlign = "center";
      _this.context.map.textBaseline = "middle";
      _this.context.map.fillStyle = "#FFF";
      _this.context.map.lineWidth = 4;
      _this.context.map.textAlign = "left";
      _this.context.map.strokeText("P", 0, textHeight);
      if ((_ref = _this.ghost1) == null) {
        _this.ghost1 = new BasicPlayer(Map.tileWidth * 6.5, textHeight, {
          direction: "right",
          color: "#F81F17"
        });
      }
      if ((_ref1 = _this.ghostRenderer1) == null) {
        _this.ghostRenderer1 = new GhostRenderer(_this.context.player, _this.ghost1, {
          radius: Map.tileWidth * 2
        });
      }
      _this.ghost1.draw(_this.ghostRenderer1);
      if ((_ref2 = _this.pacman) == null) {
        _this.pacman = new BasicPlayer(Map.tileWidth * 11.3, textHeight, {
          direction: "right"
        });
      }
      if ((_ref3 = _this.pacmanRenderer) == null) {
        _this.pacmanRenderer = new PacmanRenderer(_this.context.player, _this.pacman, {
          radius: Map.tileWidth * 2
        });
      }
      _this.pacman.draw(_this.pacmanRenderer);
      _this.context.map.strokeText("M", Map.tileWidth * 14.2, textHeight);
      if ((_ref4 = _this.ghost2) == null) {
        _this.ghost2 = new BasicPlayer(Map.tileWidth * 21.2, textHeight, {
          direction: "left",
          color: "#FACE26"
        });
      }
      if ((_ref5 = _this.ghostRenderer2) == null) {
        _this.ghostRenderer2 = new GhostRenderer(_this.context.player, _this.ghost2, {
          radius: Map.tileWidth * 2
        });
      }
      _this.ghost1.draw(_this.ghostRenderer2);
      _this.context.map.strokeText("N", Map.tileWidth * 24.4, textHeight);
      _this.context.map.closePath();
      _this.writeText("● Desenvolvido em Javascript", 18);
      return _this.writeText("● Interação multiplayer", 22);
    };
    slides[14] = function() {
      return _this.writeTitle("Ferramentas Utilizadas", {
        fontSize: 2.5
      });
    };
    slides[15] = function() {
      _this.slides[14]();
      _this.writeText("● Javascript: Linguagem de programação", 9);
      return _this.writeText("utilizada", 11);
    };
    slides[16] = function() {
      _this.slides[15]();
      _this.writeText("● Canvas do HTML 5: Renderização de", 14);
      return _this.writeText("gráficos", 16);
    };
    slides[17] = function() {
      _this.slides[16]();
      _this.writeText("● Coffeescript: Melhor sintaxe para o", 19);
      return _this.writeText("Javascript", 21);
    };
    slides[18] = function() {
      _this.slides[17]();
      return _this.writeText("● Node.js: Javascript no servidor", 24);
    };
    slides[19] = function() {
      return _this.writeTitle("Javascript");
    };
    slides[20] = function() {
      _this.slides[19]();
      return _this.writeText("● Criada pela Netscape em 1995", 9);
    };
    slides[21] = function() {
      _this.slides[20]();
      _this.writeText("● Nomes: Mocha, Livescript e finalmente", 13);
      return _this.writeText("Javascript", 15);
    };
    slides[22] = function() {
      _this.slides[21]();
      return _this.writeText("● Linguagem destinada a web", 19);
    };
    slides[23] = function() {
      _this.slides[22]();
      return _this.writeText("● Simples e Versátil", 23);
    };
    slides[24] = function() {
      return _this.writeTitle("HTML 5 Canvas");
    };
    slides[25] = function() {
      _this.slides[24]();
      _this.writeText("● Criado pela Apple em 2004 para", 8);
      return _this.writeText("implementar widgets do Dashboard", 10);
    };
    slides[26] = function() {
      _this.slides[25]();
      _this.writeText("● Posteriormente implementado nos", 13);
      return _this.writeText("navegadores Firefox Opera e Safari", 15);
    };
    slides[27] = function() {
      _this.slides[26]();
      _this.writeText("● Marcador que permite desenhar gráficos", 18);
      return _this.writeText("utilizando a linguagem Javascript", 20);
    };
    slides[28] = function() {
      _this.slides[27]();
      _this.writeText("● Possível renderizar textos, imagens, ", 23);
      _this.writeText("aplicar cores, rotações, transparências, ", 25);
      _this.writeText("manipulação de pixels, vários tipos de linhas", 27);
      return _this.writeText("e curvas, etc", 29);
    };
    slides[29] = function() {
      return _this.writeTitle("Coffeescript");
    };
    slides[30] = function() {
      _this.slides[29]();
      _this.writeText("● Linguagem que quando compilada gera", 8);
      return _this.writeText("Javascript", 10);
    };
    slides[31] = function() {
      _this.slides[30]();
      return _this.writeText("● Torna a sintaxe do Javascript mais limpa", 13);
    };
    slides[32] = function() {
      _this.slides[31]();
      _this.writeText("● Sintaxe inspirada nas linguagens Ruby e", 16);
      return _this.writeText("Python", 18);
    };
    slides[33] = function() {
      _this.slides[32]();
      _this.writeText("● Sem necessidade de chaves e ponto e", 21);
      return _this.writeText("vírgula", 23);
    };
    slides[34] = function() {
      _this.slides[33]();
      _this.writeText("● Pode-se usar qualquer biblioteca", 26);
      return _this.writeText("Javascript", 28);
    };
    slides[35] = function() {
      return _this.writeTitle("Node.js");
    };
    slides[36] = function() {
      _this.slides[35]();
      return _this.writeText("● Criada por Ryan Dalh em 2009", 9);
    };
    slides[37] = function() {
      _this.slides[36]();
      return _this.writeText("● Utiliza Javascript para Servidor", 13);
    };
    slides[38] = function() {
      _this.slides[37]();
      return _this.writeText("● Linguagem não obstrutiva", 17);
    };
    slides[39] = function() {
      _this.slides[38]();
      _this.writeText("● Perfeita para jogos com interação", 21);
      return _this.writeText("multi-jogador em tempo real", 23);
    };
    slides[40] = function() {
      _this.writeTitle("Implementação");
      _this.writeText("● Loop principal", 8);
      _this.writeText("● Mapa", 11);
      _this.writeText("● Entidades", 14);
      _this.writeText("● Personagens", 17);
      _this.writeText("● Renderizador de Personagens", 20);
      return _this.writeText("● Integração", 23);
    };
    slides[41] = function() {
      return _this.writeTitle("Loop Principal");
    };
    slides[42] = function() {
      _this.slides[41]();
      _this.writeText("● Necessário para que haja animação e", 8);
      return _this.writeText("interação", 10);
    };
    slides[43] = function() {
      _this.slides[42]();
      _this.writeText("● Atualização (verificar colisões, alterar", 14);
      return _this.writeText("direção e deslocar as personagens, etc)", 16);
    };
    slides[44] = function() {
      _this.slides[43]();
      return _this.writeText("● Apagar e desenhar", 20);
    };
    slides[45] = function() {
      _this.deleteGame();
      _this.presentation.resume();
      _this.slides[44]();
      return _this.writeText("● 60 interações por segundo", 24);
    };
    slides[46] = function() {
      var timeout;
      _this.presentation.pause();
      _this.deleteGame();
      return timeout = setTimeout(function() {
        var _ref;
        if ((_ref = _this.game) == null) {
          _this.game = new Game;
        }
        return clearTimeout(timeout);
      }, 100);
    };
    slides[47] = function() {
      var timeout;
      _this.presentation.pause();
      _this.deleteGame();
      return timeout = setTimeout(function() {
        var character, _i, _len, _ref, _ref1;
        if ((_ref = _this.game) == null) {
          _this.game = new Game;
        }
        _ref1 = _this.game.characters;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          character = _ref1[_i];
          character.calculateDisplacement = function() {
            return false;
          };
          character.displacement = 1;
        }
        _this.game.message = "";
        _this.game.delayTimer.timeOver = function() {
          return true;
        };
        _this.game.tick = function() {
          _this.game.update();
          _this.game.draw();
          _this.game.map.draw(_this.context.map);
          return setTimeout(function() {
            _this.presentation.clearAllCanvas();
            return setTimeout((function() {
              return _this.game.loop();
            }), 200);
          }, 800);
        };
        return clearTimeout(timeout);
      }, 100);
    };
    slides[48] = function() {
      _this.deleteGame();
      _this.presentation.resume();
      return _this.writeTitle("Mapa");
    };
    slides[49] = function() {
      return _this.presentation.map.draw(_this.context.map);
    };
    slides[50] = function() {
      return _this.presentation.map.drawTilesType(_this.context.map);
    };
    slides[51] = function() {
      _this.presentation.map.draw(_this.context.map);
      return _this.presentation.map.drawTilesType(_this.context.map);
    };
    slides[52] = function() {
      _this.deleteGame();
      _this.presentation.resume();
      _this.presentation.map.draw(_this.context.map);
      return _this.presentation.map.drawGrid(_this.context.map);
    };
    slides[53] = function() {
      var timeout;
      _this.deleteGame();
      _this.presentation.pause();
      return timeout = setTimeout(function() {
        var pacman, tile, _ref;
        if ((_ref = _this.game) == null) {
          _this.game = new Game;
        }
        pacman = _this.game.pacman;
        tile = _this.game.map.tiles[2][14];
        pacman.direction.set("down");
        pacman.position.set(tile.centerCoordinate());
        pacman.canMove = function() {
          return true;
        };
        _this.game.draw = function() {
          _this.presentation.clearAllCanvas();
          pacman.draw(_this.context.player);
          return pacman.drawPosition(_this.context.player);
        };
        return clearTimeout(timeout);
      }, 100);
    };
    slides[54] = function() {
      var timeout;
      _this.deleteGame();
      _this.presentation.pause();
      return timeout = setTimeout(function() {
        var pacman, tile, _ref;
        if ((_ref = _this.game) == null) {
          _this.game = new Game;
        }
        pacman = _this.game.pacman;
        tile = _this.game.map.tiles[14][2];
        pacman.direction.set("right");
        pacman.position.set(tile.centerCoordinate());
        pacman.canMove = function() {
          return true;
        };
        _this.game.draw = function() {
          _this.presentation.clearAllCanvas();
          pacman.draw(_this.context.player);
          return pacman.drawPosition(_this.context.player);
        };
        return clearTimeout(timeout);
      }, 100);
    };
    slides[55] = function() {
      _this.deleteGame();
      _this.presentation.resume();
      _this.writeTitle("Entidades");
      _this.writeText("● São entidades: personagens (Pacman", 9);
      _this.writeText("e fantasmas) e comida", 11);
      _this.writeText("● Toda entidade possui uma cordenada X,", 16);
      return _this.writeText("Y e uma área de limite", 18);
    };
    slides[56] = function() {
      var timeout;
      _this.presentation.pause();
      return timeout = setTimeout(function() {
        var _ref;
        if ((_ref = _this.game) == null) {
          _this.game = new Game;
        }
        _this.game.draw = function() {
          var entities, entity, food, player, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _results;
          _this.game.canvas.player.width = _this.game.canvas.player.width;
          _ref1 = _this.game.foods;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            food = _ref1[_i];
            food.draw(_this.context.player);
          }
          _ref2 = _this.game.characters;
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            player = _ref2[_j];
            player.draw(_this.context.player);
          }
          entities = _this.game.characters.concat(_this.game.map.remainingFoods());
          _results = [];
          for (_k = 0, _len2 = entities.length; _k < _len2; _k++) {
            entity = entities[_k];
            _results.push(entity.drawBoundingBox(_this.context.player));
          }
          return _results;
        };
        return clearTimeout(timeout);
      }, 100);
    };
    slides[57] = function() {
      _this.deleteGame();
      if (_this.angle) {
        delete _this.angle;
      }
      _this.presentation.resume();
      _this.writeTitle("Personagens");
      _this.writeText("● Possuem área delimitadora, posição,", 9);
      _this.writeText("direção, velocidade e deslocamento", 11);
      _this.writeText("● Direção definida pelo jogador", 15);
      _this.writeText("● Fórmula de deslocamento:", 19);
      _this.writeText("deslocamento = velocidade / fps", 21);
      _this.writeText("● Fórmula de movimentação:", 25);
      return _this.writeText("posição(x,y) + (direção(x,y) * deslocamento)", 27);
    };
    slides[58] = function() {
      return _this.writeTitle("Renderizador de Personagens", {
        fontSize: 1.9
      });
    };
    slides[59] = function() {
      var radius, x, y, _ref;
      _this.slides[58]();
      if ((_ref = _this.angle) == null) {
        _this.angle = 0.3;
      }
      if (_this.angle < 1.7) {
        _this.angle += 0.01;
      }
      radius = Map.tileWidth * 4;
      x = _this.map.width / 2;
      y = Map.tileHeight * 15;
      _this.context.map.beginPath();
      _this.context.map.strokeStyle = "#FF0";
      _this.context.map.arc(x, y, radius, Math.PI * 0.3, Math.PI * _this.angle, false);
      _this.context.map.stroke();
      return _this.context.map.closePath();
    };
    slides[60] = function() {
      var radius, x, y;
      if (_this.angle) {
        delete _this.angle;
      }
      _this.slides[58]();
      radius = Map.tileWidth * 4;
      x = _this.map.width / 2;
      y = Map.tileHeight * 15;
      _this.context.map.beginPath();
      _this.context.map.save();
      _this.context.map.translate(x, y);
      _this.context.map.strokeStyle = "#FF0";
      _this.context.map.arc(0, 0, radius, Math.PI * 0.3, Math.PI * 1.7, false);
      _this.context.map.lineTo(-(radius / 4), 0);
      _this.context.map.stroke();
      _this.context.map.restore();
      return _this.context.map.closePath();
    };
    slides[61] = function() {
      var radius, x, y;
      _this.slides[58]();
      radius = Map.tileWidth * 4;
      x = _this.map.width / 2;
      y = Map.tileHeight * 15;
      _this.context.map.beginPath();
      _this.context.map.save();
      _this.context.map.translate(x, y);
      _this.context.map.fillStyle = "#FF0";
      _this.context.map.arc(0, 0, radius, Math.PI * 0.3, Math.PI * 1.7, false);
      _this.context.map.lineTo(-(radius / 4), 0);
      _this.context.map.fill();
      _this.context.map.restore();
      return _this.context.map.closePath();
    };
    slides[62] = function() {
      if (_this.ghost) {
        delete _this.ghost;
      }
      if (_this.ghostRenderer) {
        delete _this.ghostRenderer;
      }
      return _this.slides[58]();
    };
    slides[63] = function() {
      var radius, x, y, _ref, _ref1;
      _this.slides[58]();
      x = _this.map.width / 2;
      y = Map.tileHeight * 15;
      radius = Map.tileWidth * 4;
      if ((_ref = _this.ghost) == null) {
        _this.ghost = new BasicPlayer(x, y, {
          direction: "right",
          color: "#F81F17"
        });
      }
      if ((_ref1 = _this.ghostRenderer) == null) {
        _this.ghostRenderer = new GhostRenderer(_this.context.player, _this.ghost, {
          radius: radius
        });
      }
      return _this.ghostRenderer.drawEyeBalls();
    };
    slides[64] = function() {
      var radius, x, y, _ref, _ref1;
      _this.slides[58]();
      x = _this.map.width / 2;
      y = Map.tileHeight * 15;
      radius = Map.tileWidth * 4;
      if ((_ref = _this.ghost) == null) {
        _this.ghost = new BasicPlayer(x, y, {
          direction: "right",
          color: "#F81F17"
        });
      }
      if ((_ref1 = _this.ghostRenderer) == null) {
        _this.ghostRenderer = new GhostRenderer(_this.context.player, _this.ghost, {
          radius: radius
        });
      }
      _this.ghostRenderer.drawEyeBalls();
      return _this.ghostRenderer.drawPupils();
    };
    slides[65] = function() {
      var radius, x, y, _ref, _ref1;
      _this.slides[58]();
      x = _this.map.width / 2;
      y = Map.tileHeight * 15;
      radius = Map.tileWidth * 4;
      if ((_ref = _this.ghost) == null) {
        _this.ghost = new BasicPlayer(x, y, {
          direction: "right",
          color: "#F81F17"
        });
      }
      if ((_ref1 = _this.ghostRenderer) == null) {
        _this.ghostRenderer = new GhostRenderer(_this.context.player, _this.ghost, {
          radius: radius
        });
      }
      _this.ghostRenderer.drawBody(_this.ghost.color);
      _this.ghostRenderer.drawEyeBalls();
      return _this.ghostRenderer.drawPupils();
    };
    slides[66] = function() {
      var radius, x, y, _ref, _ref1;
      _this.slides[58]();
      x = _this.map.width / 2;
      y = Map.tileHeight * 15;
      radius = Map.tileWidth * 4;
      if ((_ref = _this.ghost) == null) {
        _this.ghost = new BasicPlayer(x, y, {
          direction: "right",
          color: "#F81F17"
        });
      }
      if ((_ref1 = _this.ghostRenderer) == null) {
        _this.ghostRenderer = new GhostRenderer(_this.context.player, _this.ghost, {
          radius: radius
        });
      }
      return _this.ghost.draw(_this.ghostRenderer);
    };
    slides[67] = function() {
      return _this.writeTitle("Visão Geral");
    };
    slides[68] = function() {
      _this.slides[67]();
      return _this.drawIntegratorImage(1);
    };
    slides[69] = function() {
      _this.slides[67]();
      return _this.drawIntegratorImage(2);
    };
    slides[70] = function() {
      _this.slides[67]();
      return _this.drawIntegratorImage(3);
    };
    slides[71] = function() {
      _this.slides[67]();
      return _this.drawIntegratorImage(4);
    };
    slides[72] = function() {
      _this.slides[67]();
      return _this.drawIntegratorImage(5);
    };
    slides[73] = function() {
      _this.slides[67]();
      return _this.drawIntegratorImage(6);
    };
    slides[74] = function() {
      _this.slides[67]();
      return _this.drawIntegratorImage(7);
    };
    slides[75] = function() {
      _this.slides[67]();
      return _this.drawIntegratorImage(8);
    };
    slides[76] = function() {
      _this.slides[67]();
      return _this.drawIntegratorImage(9);
    };
    slides[77] = function() {
      _this.slides[67]();
      return _this.drawIntegratorImage(10);
    };
    return slides;
  };

  return Slide;

})();

Presentation = (function() {
  var MAX_FPS;

  MAX_FPS = 60;

  function Presentation() {
    this.tick = __bind(this.tick, this);

    this.handleKey = __bind(this.handleKey, this);

    var canvas, name, _i, _len, _ref;
    this.map = new Map;
    this.canvas = {};
    this.context = {};
    _ref = $("canvas");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      canvas = _ref[_i];
      name = canvas.id.replace("_canvas", "");
      this.canvas[name] = document.getElementById(canvas.id);
      this.canvas[name].width = this.map.matrix[0].length * Map.tileWidth;
      this.canvas[name].height = this.map.matrix.length * Map.tileHeight;
      this.context[name] = this.canvas[name].getContext("2d");
    }
    this.map.draw(this.context.map);
    this.fpsTimer = new Timer(1000);
    this.slide = new Slide(this);
    this.status = "running";
    this.loop();
  }

  Presentation.prototype.handleKey = function(e) {
    switch (e.which) {
      case 39 || 13:
        return this.slide.next();
      case 37:
        return this.slide.previous();
    }
  };

  Presentation.prototype.pause = function() {
    this.status = "paused";
    return this.clearAllCanvas();
  };

  Presentation.prototype.paused = function() {
    return this.status === "paused";
  };

  Presentation.prototype.resume = function() {
    if (!this.running()) {
      this.loop();
    }
    return this.status = "running";
  };

  Presentation.prototype.running = function() {
    return this.status === "running";
  };

  Presentation.prototype.update = function() {};

  Presentation.prototype.clearAllCanvas = function() {
    var canvas, type, _ref, _results;
    _ref = this.canvas;
    _results = [];
    for (type in _ref) {
      canvas = _ref[type];
      _results.push(canvas.width = canvas.width);
    }
    return _results;
  };

  Presentation.prototype.draw = function() {
    this.clearAllCanvas();
    return this.slide.draw();
  };

  Presentation.prototype.loop = function() {
    return requestAnimationFrame(this.tick);
  };

  Presentation.prototype.tick = function() {
    this.update();
    this.draw();
    if (this.running()) {
      return this.loop();
    }
  };

  return Presentation;

})();

jQuery(function($) {
  var presentation;
  presentation = new Presentation;
  $(".wrapper").css({
    "width": "" + presentation.map.width + "px",
    "height": "" + presentation.map.height + "px"
  });
  return $(document).on("keyup", presentation.handleKey);
});
